name: Build & Publish to Groupez

on:
  push:
    tags:
      - 'v*.*.*'   # Trigger on semantic version tags like v1.2.3
  workflow_dispatch:

permissions:
  contents: read

env:
  REPO_URL: https://repo.groupez.dev/releases

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    env:
      GROUPEZ_USER: ${{ secrets.GROUPEZ_USER }}
      GROUPEZ_PASS: ${{ secrets.GROUPEZ_PASS }}
      GROUPEZ_API_KEY: ${{ secrets.GROUPEZ_API_KEY }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17
          cache: gradle

      - name: Cache Gradle files
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: gradle-cache-${{ runner.os }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            gradle-cache-${{ runner.os }}-

      - name: Ensure gradlew is executable
        run: chmod +x ./gradlew

      - name: Set version from tag (if present)
        id: set_version
        run: |
          if [[ "${GITHUB_REF##*/}" =~ ^v[0-9] ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            VERSION="${TAG#v}"
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            echo "Detected tag $TAG, version set to $VERSION"
          else
            echo "version=dev" >> $GITHUB_OUTPUT
            echo "No tag detected; version set to 'dev'"
          fi

      - name: Test basic auth to repository (prints HTTP status)
        if: env.GROUPEZ_USER != '' && env.GROUPEZ_PASS != ''
        run: |
          http_code=$(curl -s -o /dev/null -w "%{http_code}" -u "${GROUPEZ_USER}:${GROUPEZ_PASS}" "${REPO_URL}/")
          echo "Repository HTTP status: $http_code"
          if [ "$http_code" -ge 400 ]; then
            echo "Warning: repository returned HTTP $http_code for basic auth test"
          fi

      - name: Build project and create shadow JAR
        run: |
          ./gradlew --no-daemon clean :API:shadowJar -Pversion="${{ steps.set_version.outputs.version }}" --info
        env:
          JAVA_TOOL_OPTIONS: -Xmx2g

      - name: Find API artifact (jar)
        id: find_api_jar
        run: |
          JAR=$(find API/build/libs -maxdepth 1 -type f -name "*.jar" ! -name "*sources*" ! -name "*javadoc*" | head -n 1 || true)
          if [ -z "$JAR" ]; then
            echo "No JAR found in API/build/libs"
            exit 1
          fi
          echo "Found JAR: $JAR"
          echo "jar_path=$JAR" >> $GITHUB_OUTPUT
          echo "jar_name=$(basename "$JAR")" >> $GITHUB_OUTPUT
          GROUP_PATH="fr/maxlego08/essentials/zessentials-api/${{ steps.set_version.outputs.version }}"
          echo "upload_path=$GROUP_PATH" >> $GITHUB_OUTPUT

      - name: Publish with Gradle to Groupez (basic auth)
        id: gradle_publish
        run: |
          ./gradlew --no-daemon :API:publish \
            -PgroupezUser="${GROUPEZ_USER}" -PgroupezPass="${GROUPEZ_PASS}" \
            -Pversion="${{ steps.set_version.outputs.version }}" --info
        continue-on-error: true

      - name: Fallback: Upload artifact via API key header if publish failed
        if: failure()
        env:
          API_KEY: ${{ env.GROUPEZ_API_KEY }}
          JAR_PATH: ${{ steps.find_api_jar.outputs.jar_path }}
          UPLOAD_PATH: ${{ steps.find_api_jar.outputs.upload_path }}
          JAR_NAME: ${{ steps.find_api_jar.outputs.jar_name }}
          REPO_URL: ${{ env.REPO_URL }}
        run: |
          if [ -z "$API_KEY" ]; then
            echo "No API key provided; skipping fallback."
            exit 0
          fi
          if [ -z "$JAR_PATH" ] || [ ! -f "$JAR_PATH" ]; then
            echo "Artifact not found at $JAR_PATH"
            exit 1
          fi
          TARGET_URL="${REPO_URL}/${UPLOAD_PATH}/${JAR_NAME}"
          echo "Uploading ${JAR_NAME} to ${TARGET_URL}"
          # Replace "X-API-Key" with the header your registry expects
          curl -sS --fail -H "X-API-Key: ${API_KEY}" --upload-file "${JAR_PATH}" "${TARGET_URL}"

      - name: Final status
        if: success()
        run: echo "Publish job completed successfully."

      - name: Final failure notice
        if: failure()
        run: |
          echo "Publish job failed. Check previous steps for details. Ensure GROUPEZ_USER/GROUPEZ_PASS are correct or use GROUPEZ_API_KEY for header-based uploads."
